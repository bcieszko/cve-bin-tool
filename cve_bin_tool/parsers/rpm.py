# Copyright (C) 2022 Intel Corporation
# SPDX-License-Identifier: GPL-3.0-or-later

from enum import Enum, IntEnum
import io


from cve_bin_tool.parsers import Parser
from cve_bin_tool.util import ProductInfo, ScanInfo

class RpmParser(Parser):
    class Type(IntEnum):
        NULL = 0
        CHAR = 1
        INT8 = 2
        INT16 = 3
        INT32 = 4
        INT64 = 5
        STRING = 6
        BIN = 7
        STRING_ARRAY = 8
        I18NSTRING_TYPE = 9

    class Tag(IntEnum):
        RPMTAG_NAME = 1000
        RPMTAG_VERSION = 1001
        RPMTAG_RELEASE = 1002

    TAGS_TO_PARSE = [Tag.RPMTAG_NAME, Tag.RPMTAG_VERSION, Tag.RPMTAG_RELEASE]

    RPM_LEAD_MAGIC=b"\xed\xab\xee\xdb"
    RPM_HEADER_MAGIC=b"\x8e\xad\xe8"

    def __init__(self, cve_db, logger, validate=True):
        super().__init__(cve_db, logger)
        self.validate = validate

    @staticmethod
    def parse_tag(tag):
        return tag in RpmParser.TAGS_TO_PARSE

    def find_vendor(self, product, version):
        """Find vendor for Java product"""
        vendor_package_pair = self.cve_db.get_vendor_product_pairs(product)
        # If no match, try alternative product name.
        # Apache product names are stored as A_B in NVD database but often called A-B
        # Some packages have -parent appended to product which is not in NVD database
        if vendor_package_pair == [] and "-" in product:
            self.logger.debug(f"Try alternative product {product}")
            # Remove parent appendage
            if "-parent" in product:
                product = product.replace("-parent", "")
            product = product.replace("-", "_")
            vendor_package_pair = self.cve_db.get_vendor_product_pairs(product)
            if vendor_package_pair != []:
                info = []
                for pair in vendor_package_pair:
                    vendor = pair["vendor"]
                    file_path = self.filename
                    self.logger.debug(f"{file_path} {product} {version} by {vendor}")
                    info.append(
                        ScanInfo(ProductInfo(vendor, product, version), file_path)
                    )
                return info
        return None

    

    def validate_rpm(self, filename):
        with open(filename, 'rb') as rpm:
            rpm_lead_magic = rpm.read(len(self.RPM_LEAD_MAGIC))
            if self.RPM_LEAD_MAGIC == rpm_lead_magic:
                return True
        return False

    # 4 magic
    # 2 major, minor
    # 2 type
    # 2 archnum
    # 66 name
    # 2 osnum
    # 2 signature_type
    # 16 reserved
    RPM_LEAD_LEN = 96
    RPM_LEAD_NAME_OFFSET = 10
    RPM_LEAD_NAME_LEN = 66
    RPM_HEADER_LEN = 16
    RPM_HEADER_INDEX_LEN = 16

    def get_rpm_entry(self, rpm, rpm_size, base_offset, entry_type, offset, count):
        if rpm_size < (base_offset + offset + count):
            self.logger.error(f"{self.filename} - entry corrupted")
            return None
        rpm.seek(base_offset + offset)
        data = b""
        if entry_type == self.Type.STRING:
            # string can only have count 1
            char = rpm.read(1)
            while char != b"\x00":
                data += char
                char = rpm.read(1)
        else:
            data = rpm.read(count)
        rpm_entry = None
        if entry_type == self.Type.STRING:
            try:
                rpm_entry = data.rstrip(b'\x00').decode('ascii')
            except UnicodeError:
                self.logger.error(f"{self.filename} - {data} - invalid string in rpm with nonascii characters at offset 0x{base_offset+offset:X}")
        else:
            pass
            # unsupported - if more info is needed feel free to add parsing here
            # at the moment all the data that is extracted is string
        return rpm_entry



    def extract_info(self):
        # File structure is as follows:
        # Lead
        # Signature
        # Header
        # Payload
        
        # open: os.stat? and check file length beforehand
        with open(self.filename, 'rb') as rpm:
            rpm.seek(0, io.SEEK_END)
            rpm_size = rpm.tell()
            rpm.seek(0)

            # Lead
            rpm_lead = rpm.read(self.RPM_LEAD_LEN)
            if len(rpm_lead) != self.RPM_LEAD_LEN:
                # file corrupted
                self.logger.error(f"{self.filename} - file is too short, possibly corrupted")
                return False
            name_bytes = rpm_lead[self.RPM_LEAD_NAME_OFFSET:self.RPM_LEAD_NAME_LEN+1]
            try:
                self.name = name_bytes.rstrip(b'\x00').decode('ascii')
            except UnicodeError:
                self.logger.error(f"{self.filename} - invalid name in rpm with nonascii characters")
                return False

            self.logger.debug(f"{self.filename} - RPM Lead OK")
            self.logger.error(f"{self.filename} - {self.name}")

            # Signature / Header
            # 3 bytes magic
            # 1 byte version
            # 4 bytes reserved
            # 4 bytes number of index entries
            # 4 bytes data size
            # n i* 16 index entries

            # Signature and header have the same structure
            header = rpm.read(self.RPM_HEADER_LEN)
            if len(header) != self.RPM_HEADER_LEN:
                self.logger.error(f"{self.filename} - file is too short, possibly corrupted")
                return False

            if header[0:3] != self.RPM_HEADER_MAGIC:
                self.logger.error(f"{self.filename} - corrupted RPM signature header")
                return False

            entries = int.from_bytes(header[8:12], byteorder="big")
            data_size = int.from_bytes(header[12:16], byteorder="big")
            self.logger.error(f"index entries: {entries}")

            # skip signature indexes and data
            target_offset = rpm.tell() + (entries * self.RPM_HEADER_INDEX_LEN + data_size)
            # Header is aligned to 8-byte boundary
            if target_offset % 8:
                target_offset = target_offset - (target_offset % 8) + 8

            if target_offset > rpm_size:
                self.logger.error(f"{self.filename} - corrupted RPM")
                return False

            rpm.seek(target_offset)

            # Header
            header = rpm.read(self.RPM_HEADER_LEN)
            if len(header) != self.RPM_HEADER_LEN:
                self.logger.error(f"{self.filename} - file is too short, possibly corrupted")
                return False

            if header[0:3] != self.RPM_HEADER_MAGIC:
                self.logger.error(f"{self.filename} - corrupted RPM header - {header}")
                return False

            entries = int.from_bytes(header[8:12], byteorder="big")
            data_size = int.from_bytes(header[12:16], byteorder="big")
            self.logger.error(f"index entries: {entries}")

            header_entries_offset = rpm.tell()
            target_offset = rpm.tell() + (entries * self.RPM_HEADER_INDEX_LEN + data_size)
            # Header is aligned to 8-byte boundary
            if target_offset % 8:
                target_offset = target_offset - (target_offset % 8) + 8

            if target_offset > rpm_size:
                self.logger.error(f"{self.filename} - corrupted RPM")
                return False

            # Index Entry
            # 4 bytes Tag
            # 4 bytes Type
            # 4 bytes Offset
            # 4 bytes Count
            # Parse through index entries
            data_offset = header_entries_offset + (entries * self.RPM_HEADER_INDEX_LEN)
            for i in range(0, entries):
                entry_raw = rpm.read(self.RPM_HEADER_INDEX_LEN)
                entry_tag = int.from_bytes(entry_raw[0:4], byteorder="big")
                entry_type = self.Type(int.from_bytes(entry_raw[4:8], byteorder="big"))
                entry_offset = int.from_bytes(entry_raw[8:12], byteorder="big")
                entry_count = int.from_bytes(entry_raw[12:16], byteorder="big")
                #if False:
                #if self.parse_tag(entry_tag):
                if entry_type == self.Type.STRING:
                #if entry_tag == 1000:
                    restore_offset = rpm.tell()
                    rpm_entry = self.get_rpm_entry(rpm, rpm_size, data_offset, entry_type, entry_offset, entry_count)
                    rpm.seek(restore_offset)
                    self.logger.error(f"{entry_tag} - {entry_type} - {entry_offset} - {entry_count} - data: {rpm_entry}")



    def run_checker(self, filename):
        """Process SPEC file and extract product"""
        self.filename = filename
        continue_processing = True
        if self.validate:
            continue_processing = self.validate_rpm(self.filename)
            self.logger.info(f"Validation of {filename} - {continue_processing}")
        if continue_processing:
            self.logger.info(f"file ok")
            self.extract_info()
        yield ScanInfo(ProductInfo("unknown", "unknown", "0.0"), self.filename)


        """   
        if self.validate:
            continue_processing = validate_pom(filename)
            self.logger.debug(f"Validation of {filename} - {continue_processing}")
        if continue_processing:
            tree = ET.parse(filename)
            # Find root element
            root = tree.getroot()
            # Extract schema
            schema = root.tag[: root.tag.find("}") + 1]
            parent = root.find(schema + "parent")
            version = None
            product = None
            file_path = self.filename
            # Parent tag is optional.
            if parent is None:
                product = root.find(schema + "artifactId").text
                version = root.find(schema + "version").text
            if version is None and parent is not None:
                version = parent.find(schema + "version").text

            # If no version has been found, set version to UNKNOWN
            if version is None:
                version = "UNKNOWN"

            # Check valid version identifier (i.e. starts with a digit)
            if not version[0].isdigit():
                self.logger.debug(f"Invalid {version} detected in {filename}")
                version = None
            if product is None and parent is not None:
                product = parent.find(schema + "artifactId").text
            if product is not None and version is not None:
                product_info = self.find_vendor(product, version)
                if product_info is not None:
                    yield from product_info

            # Some version strings are defined as properties.
            # Build up dictionary of values in same format ${name} : {value}
            properties = root.find(schema + "properties")
            java_props = {}
            if properties is not None:
                for prop in properties:
                    # Remove the schema from tag
                    tag = prop.tag[prop.tag.find("}") + 1 :]
                    java_props["${" + tag + "}"] = prop.text

            # Scan for any dependencies referenced in file
            dependencies = root.find(schema + "dependencies")
            if dependencies is not None:
                for dependency in dependencies.findall(schema + "dependency"):
                    product = dependency.find(schema + "artifactId")
                    if product is not None:
                        version = dependency.find(schema + "version")
                        if version is not None:
                            version = version.text
                            if version[0] == "$":
                                # Check if version specified in properties
                                if version in java_props:
                                    self.logger.debug(
                                        f"Translate {version} to {java_props[version]}"
                                    )
                                    version = java_props[version]
                            self.logger.debug(f"{file_path} {product.text} {version}")
                            if version[0].isdigit():
                                # Valid version identifier
                                product_info = self.find_vendor(product.text, version)
                                if product_info is not None:
                                    yield from product_info
        self.logger.debug(f"Done scanning file: {filename}")
        """
